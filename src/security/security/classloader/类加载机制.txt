										类加载机制

                                                                                                         
Java编译器能够将源程序转化为假想机器的机器语言，这种假想机器称为虚拟机（JVM）。虚拟机代码存储在以.class为扩展名的类文件中。
每个类文件都包含某个类或者接口的定义及代码实现。这些类文件必须由一个解释器进行解释，该解释器能够将虚拟机的指令集翻译成目标机器的机器语言。
    
虚拟机只加载程序执行时所需要的类文件。假设程序从A.class开始运行，下面是虚拟机执行的步骤：
1，虚拟机有一个用于加载类文件的机制，可从磁盘上读取文件或者请求web上的文件，它使用该机制来加载A类文件中的内容。
2，如果A类拥有类型为另一个类的实例变量，或者是拥有超类，那么这些类文件也会被加载。（加载某个类所依赖的所有类的过程称为类的解析）
3，虚拟机执行A类中的main方法。（它是静态的，不需要创建类的实例）
4，如果main方法或者main调用的方法要用到更多的类，那么接下来就会加载这些类。
    
如果在程序中通过调用Class.forName进行类的加载，那么这个新类将通过某一类加载器进行加载，而此加载器与调用Class.forName的那段代码的类加载器相同。
一般情况下这不会有什么问题，但是遇到下面的情况就不同了：
1，使用一个第三方库类，该类有一个调用Class.forName的方法。
2，该方法被一个应用类调用，加载该应用类的类加载器与加载库类的类加载器不同。
3，加载后的应用类对加载库类的类加载器是不可见的。

在上述情况下，库类需要做更多的工作，需要获取应用类加载器：

    Thread t = Thread.currentThread();
    ClassLoader loader = t.getContextClassLoader();
    Class cl = loader.loadClass(className);
    
getContextClassLoader() 方法用于获取类加载器，该线程的创建者将其指定为执行该线程时最适合使用的类加载器。


将类加载器作为名称空间

在同一个虚拟机中，可以有两个类，它们的类名和包名都是相同的。类是由它的全名和类加载器来确定的。这项技术在加载来自多处的代码时很有用。
比如浏览器为每一个web页都是用一个独立的applet类加载器的实例，这样虚拟机就可以区分来自不同web页的各个类，而不用管它们的名字是什么。