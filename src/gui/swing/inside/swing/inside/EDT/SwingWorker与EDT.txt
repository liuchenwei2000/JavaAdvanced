                                                                   SwingWorker
																   
从JDK6开始引进的SwingWorker能更轻松的编写多线程Swing程序，改善Swing程序的结构，提高界面相应的灵活性。

Swing中常见的错误是误用Swing事件派发线程(Event Dispatch Thread，EDT)，具体表现有如下几种：
1，从非UI线程访问UI组件；2，不考虑事件执行顺序；
3，不使用独立任务线程而在EDT线程上执行耗时任务，结果使编写的应用程序变得响应程度、速度很慢。
耗时计算和输入输出(IO)密集型任务不应放在EDT上运行，而应该使用独立的任务线程，SwingWorker类创建和管理任务线程。

一个Swing程序中一般有三种类型的线程：
1，初始化线程(Initial Thread)
每个程序必须有一个main方法，这是程序的入口。该方法运行在初始化或启动线程上，初始化线程读取程序参数并初始化一些对象。在许多Swing程序中，该线程主要目的是启动程序的图形用户界面(GUI)。一旦GUI启动后，初始化线程的工作就结束了。
2，UI事件派发线程(EDT)
Swing程序只有一个EDT，该线程负责GUI组件的绘制和更新，通过调用程序的事件处理器来响应用户交互。所有事件处理都是在EDT上进行的，程序同UI组件和其基本数据模型的交互只允许在EDT上进行，所有运行在EDT上的任务应该尽快完成，以便UI能及时响应用户输入。
3，任务线程(Work Thread)

使用合适的线程

初始化线程运行程序的main方法，该方法能处理很多任务。但在典型的Swing程序中，其主要任务就是创建和运行应用程序的界面。创建UI的点，也就是程序开始将控制权转交给UI时的点，往往是同EDT交互出现问题的第一个地方。一个错误的示例见 swing.inside.EDT.InitialThreadDemo.java。

Swing编程时应注意以下三点：
1，从其他线程访问UI组件及其事件处理器会导致界面更新和绘制错误。
2，在EDT上执行耗时任务会使程序失去响应，这会使GUI事件阻塞在队列中得不到处理。
3，应使用独立的任务线程来执行耗时计算或输入输出密集型任务，比如同数据库通信、访问网站资源、读写大数据量的文件。
总之，任何干扰或延迟UI事件的处理只应该出现在独立任务线程中；在初始化线程或任务线程同Swing组件或其缺省数据模型进行的交互都是非线程安全性操作。

SwingWorker类帮你管理任务线程和SwingEDT之间的交互，尽管SwingWorker不能解决并发线程中遇到的所有问题，但的确有助于分离SwingEDT和任务线程，使它们各负其责：对于EDT而言，就是绘制和更新界面，响应用户输入；对于任务线程而言，就是执行和界面无直接关系的耗时操作。可以想象EDT线程的事件队列很繁忙，几乎每一次GUI交互和时间都是通过它完成。事件队列上的任务必须非常快，否则就会阻塞其他任务的执行，使队列里阻塞了很多等待执行的事件，造成界面响应不灵活。任何需时超过30到100毫秒的任务不应放在EDT上执行，否则用户就会觉察到输入和界面相应之间的延迟。





























