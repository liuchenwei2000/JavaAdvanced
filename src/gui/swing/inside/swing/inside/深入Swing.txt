                                                              深入Swing


Swing在事件处理机制上使用的是单线程模型，它对于事件处理不保证线程安全性，所有的事件处理都在Event Dispatch Thread(EDT)上进行，此一类事件模型通常叫做单线程模型。这种模型规定所有对组件的访问操作必须在EDT上完成。这主要是为了保证对于组件状态的改变是同步的，保证了界面组件的可确定性。

单线程模型的好处是，结构设计和代码实现都比较简单，避免了为了实现线程同步的复杂处理。但也有一些问题，程序员容易将长时间复杂任务的处理放在事件处理方法中完成，造成EDT线程被阻塞，给用户造成界面失去响应的错觉。人们对于Swing速度慢和反应迟钝的感觉大部分来源于此。

如何解决这个问题？通用的办法就是采用异步线程处理长时间任务。但是还要记住，在这种任务中对于界面的更新要采用SwingUtilities.invokeLater的方式将访问操作放到EDT上进行。


1，Swing模型与渲染器

Swing提供的基于模型和渲染器的组件是构建高性能、可扩展GUI的关键。

a.Swing体系结构
MVC模式即模型-视图-控制器模式，它引入了这样一个概念：数据源应该同屏幕展现分开。Swing使用的是一个变体的MVC架构，如图MVC.png。
典型的Swing GUI组件包括至少三个对象：一个Component、一个Model和一个UI Delegate，在这个框架中，Model负责存储数据，UI Delegate负责从Model获取数据并渲染到屏幕上去，Component通常协调Model和UI Delegate之间的操作，并同时负责将Swing嵌入到AWT窗口系统中。注意，UI Delegate对象可以在运行时动态替换，这就使Swing具备了可插拔的外观。

b.矢量组件
Swing提供了一些处理大数据量数据集的组件，包括JTable、JTree、JList以及JComboBox。这些矢量组件被设计成能够处理百万级的数据，为了避免占用大量内存，这些组件在Swing的体系结构中增加了渲染器(Renderer)概念。如图MVC-Renderer.png。

c.渲染器(Renderer)
在这些更为复杂的Swing组件中，渲染器是提供可扩展性的关键。
比如JTable的每一格都有一个JLabel，对于百万级的数据而言，需要的内存可能要1G。Swing的JTable使用一个组件来画出所有相同类型的格子。比如所有的String对象的格子都使用相同的组件画。这种类型的组件被称为渲染器(Renderer)，使用渲染器显示多个表格极大的减小了对内存的占用。
当渲染器用来显示表格时，JTable从model中获取格子中的数据，然后使用这些数据对渲染器进行配置，然后使用该渲染器画出该格子。接下来，渲染器继续移动到下一个格子，然后重复这个过程。

d.模型(Model)
直接操作Swing的模型(Model)对于编写可扩展的用户界面至关重要。
代码示例见swing.inside.UsingModelDemo.java。
结论：
尽可能使用批操作，尽量减少触发事件的数量。
当初始化或者需要完全替换模型的内容时，考虑重新生成模型，不要使用已经存在的模型，已存在模型上已经保持了很多的侦听器，新生成的模型没有侦听器，这样避免了不必要的处理函数的调用。触发事件数量严重影响程序启动时间，也会影响打开对话框和相似操作的时间。
































