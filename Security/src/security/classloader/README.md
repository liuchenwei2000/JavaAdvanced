## 类加载机制 ##

Java编译器能够将源程序转化为假想机器的机器语言，这种假想机器称为虚拟机（JVM）。虚拟机代码存储在以.class为扩展名的类文件中。
每个类文件都包含某个类或者接口的定义及代码实现。这些类文件必须由一个解释器进行解释，该解释器能够将虚拟机的指令集翻译成目标机器的机器语言。
    
虚拟机只加载程序执行时所需要的类文件。假设程序从A.class开始运行，下面是虚拟机执行的步骤：

* 1，虚拟机有一个用于加载类文件的机制，可从磁盘上读取文件或者请求web上的文件，它使用该机制来加载A类文件中的内容。
* 2，如果A类拥有类型为另一个类的实例变量，或者是拥有超类，那么这些类文件也会被加载。（加载某个类所依赖的所有类的过程称为类的解析）
* 3，虚拟机执行A类中的main方法。（它是静态的，不需要创建类的实例）
* 4，如果main方法或者main调用的方法要用到更多的类，那么接下来就会加载这些类。
    
如果在程序中通过调用Class.forName进行类的加载，那么这个新类将通过某一类加载器进行加载，而此加载器与调用Class.forName的那段代码的类加载器相同。
一般情况下这不会有什么问题，但是遇到下面的情况就不同了：

* 1，使用一个第三方库类，该类有一个调用Class.forName的方法。
* 2，该方法被一个应用类调用，加载该应用类的类加载器与加载库类的类加载器不同。
* 3，加载后的应用类对加载库类的类加载器是不可见的。

在上述情况下，库类需要做更多的工作，需要获取应用类加载器：

    Thread t = Thread.currentThread();
    ClassLoader loader = t.getContextClassLoader();
    Class cl = loader.loadClass(className);
    
getContextClassLoader() 方法用于获取类加载器，该线程的创建者将其指定为执行该线程时最适合使用的类加载器。


将类加载器作为名称空间

在同一个虚拟机中，可以有两个类，它们的类名和包名都是相同的。类是由它的全名和类加载器来确定的。这项技术在加载来自多处的代码时很有用。
比如浏览器为每一个web页都是用一个独立的applet类加载器的实例，这样虚拟机就可以区分来自不同web页的各个类，而不用管它们的名字是什么。


### 字节码校验

当类加载器将新加载的Java类的字节码传递给虚拟机时，首先要接受校验器（verifier）的校验。
校验器负责检查那些无法执行的明显具有破坏性的操作。除了系统类外，所有的类都要被校验。执行的主要检查如下：

* 变量要在使用之前进行初始化。
* 方法调用与对象引用类型之间要匹配。
* 访问私有数据和方法的规则没有被违反。
* 对本地变量的访问都在运行时堆栈内。
* 运行时堆栈没有溢出。

如果上述任何一条没有通过，那么该类就被认为遭到了破坏而不予加载。这种严格的校验是出于安全上的考虑，
虽然编译器不会允许生成包含上述错误的类文件，但是程序员完全可以手工修改类文件，从而突破了编译器的安全防线。
校验器总是在防范被故意篡改的类文件，而不仅仅是检查编译器产生的类文件。
